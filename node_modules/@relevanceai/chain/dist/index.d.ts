import * as json_schema from 'json-schema';
import { C as ChainConfig, R as RunChainOptions, P as Prettify, a as RunChainOutput, b as ParamSchema, T as TypedJsonSchema, c as ParamSchemaMetadata, S as SchemaMetadata, d as ParamDefinitionInput, V as Variable, e as ParamsToTypedObject, A as AllowedTransformationId, f as TransformationInput, g as TransformationOutput, U as UnwrapVariable, J as JsCodeTransformationOutput, h as ArrayItem, i as ChainState } from './client-133e093c.js';
export { m as Client, l as CustomTransformations, I as InferChainInput, j as InferChainOutput, n as RunChainError, k as TransformationsMap } from './client-133e093c.js';
import * as zod from 'zod';
import { ZodType } from 'zod';

type APIAuthDetails = {
    project: string;
    region: string;
    apiKey: string;
};
declare class API {
    private authDetails;
    constructor(authDetails?: APIAuthDetails);
    private get token();
    private request;
    getChain(chainId: string, version?: string): Promise<ChainConfig>;
    runChain<Output extends Record<string, any>>(options: RunChainOptions<true>): Promise<Prettify<RunChainOutput<true, Output>>>;
    runChain<Output extends Record<string, any>>(options: RunChainOptions<false>): Promise<Prettify<RunChainOutput<false, Output>>>;
    saveChains(body: {
        updates: ChainConfig[];
        version?: string;
        partial_update?: boolean;
    }): Promise<any>;
    getChainsByIds(ids: string[]): Promise<ChainConfig[]>;
    shareChain(chainId: string): Promise<{
        share_link: string;
        share_id: string;
        region: string;
    }>;
    unshareChain(chainId: string, shareId: string): Promise<void>;
}

declare const jsonSchemaParam: <T extends unknown>(schema: ParamSchema<T_1>) => TypedJsonSchema<T>;
declare const zodParam: <T extends unknown>(schema: ZodType<T, zod.ZodTypeDef, T>, metadata?: ParamSchemaMetadata) => {
    order?: number | undefined;
    metadata?: SchemaMetadata | undefined;
    items?: json_schema.JSONSchema4 | undefined;
    id?: string | undefined;
    $ref?: string | undefined;
    $schema?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    default?: json_schema.JSONSchema4Type | undefined;
    multipleOf?: number | undefined;
    maximum?: number | undefined;
    exclusiveMaximum?: boolean | undefined;
    minimum?: number | undefined;
    exclusiveMinimum?: boolean | undefined;
    maxLength?: number | undefined;
    minLength?: number | undefined;
    pattern?: string | undefined;
    additionalItems?: boolean | json_schema.JSONSchema4 | undefined;
    maxItems?: number | undefined;
    minItems?: number | undefined;
    uniqueItems?: boolean | undefined;
    maxProperties?: number | undefined;
    minProperties?: number | undefined;
    required?: boolean | string[] | undefined;
    additionalProperties?: boolean | json_schema.JSONSchema4 | undefined;
    definitions?: {
        [k: string]: json_schema.JSONSchema4;
    } | undefined;
    properties?: {
        [k: string]: json_schema.JSONSchema4;
    } | undefined;
    patternProperties?: {
        [k: string]: json_schema.JSONSchema4;
    } | undefined;
    dependencies?: {
        [k: string]: string[] | json_schema.JSONSchema4;
    } | undefined;
    enum?: json_schema.JSONSchema4Type[] | undefined;
    type?: json_schema.JSONSchema4TypeName | json_schema.JSONSchema4TypeName[] | undefined; /**
     * If true, the chain will be publicly triggerable. This means that anyone
     * with the chain's ID will be able to run it and that you will be able to
     * run the chain via `client.runChain`.
     *
     */
    allOf?: json_schema.JSONSchema4[] | undefined;
    anyOf?: json_schema.JSONSchema4[] | undefined;
    oneOf?: json_schema.JSONSchema4[] | undefined;
    not?: json_schema.JSONSchema4 | undefined;
    extends?: string | string[] | undefined;
    format?: string | undefined;
    $tsType: T;
};
declare class Chain<ParamsDefinition extends ParamDefinitionInput, OutputDefinition extends Record<string, any>> {
    $RELEVANCE_CHAIN_BRAND: boolean;
    protected api: API;
    private chainId;
    private params;
    private steps;
    private output;
    private title;
    private description;
    private publiclyTriggerable;
    constructor(authDetails?: APIAuthDetails);
    setTitle(title: string): void;
    setDescription(description: string): void;
    setPubliclyTriggerable(value: boolean): void;
    defineParams<InnerParamsDefinition extends ParamsDefinition>(params: InnerParamsDefinition): Variable<Prettify<ParamsToTypedObject<InnerParamsDefinition>>>;
    /**
     * Add a step to your chain. You can call this multiple times to add
     * multiple steps to your chain.
     *
     * @returns A variable that references the output of the step.
     *
     * @example
     * const { prompt, answer } = step('prompt_completion', {
     *   prompt: 'Write a short story about dogs',
     * })
     */
    step<TransformationId extends AllowedTransformationId>(transformation: TransformationId, params: TransformationInput<TransformationId>): Variable<TransformationOutput<TransformationId>>;
    private runIfContext;
    runIf<Fn extends () => any>(condition: any | Variable<any>, fn: Fn): ReturnType<Fn>;
    code<CodeParams extends Record<string, Variable<any>>, Fn extends (params: UnwrapVariable<CodeParams>) => any>(params: CodeParams, fn: Fn): Omit<JsCodeTransformationOutput, "transformed"> & {
        transformed: Variable<ReturnType<Fn>>;
    };
    private foreachContext;
    /**
     * Run 1 step for each item in the array.
     *
     * Note: foreach for multiple steps at once is not supported at the moment.
     */
    foreach<Var extends any[] | Variable<any[]>, Fn extends (foreachData: {
        item: Variable<ArrayItem<UnwrapVariable<Var>>>;
        index: number;
    }) => ReturnType<(typeof Chain)["prototype"]["step"]>>(variable: Var, fn: Fn): Variable<Array<ReturnType<Fn>>>;
    defineOutput(output: OutputDefinition): void;
    toJSON(): ChainConfig;
    setChainId(chainId: string): void;
    getChainId(): string | null;
    run(params: ParamsToTypedObject<ParamsDefinition>): Promise<{
        status: "complete" | "inprogress" | "failed" | "cancelled";
        output: UnwrapVariable<OutputDefinition>;
        executionTime?: number;
        errors: {
            raw: string;
            body: string;
            stepName?: string;
        }[];
        state: ChainState;
    }>;
    static define: <ChainParamsDefinition extends ParamDefinitionInput, ChainOutputDefinition extends Record<string, any>>(input: {
        title?: string;
        description?: string;
        /**
         * If true, the chain will be publicly triggerable. This means that anyone
         * with the chain's ID will be able to run it and that you will be able to
         * run the chain via `client.runChain`.
         *
         */
        publiclyTriggerable?: boolean;
        /**
         * Schemas for the inputs to your chain. This is optional, but if provided,
         * we will check that the inputs to your chain are valid at runtime, and
         * you get autocomplete for the inputs to your chain.
         */
        params?: ChainParamsDefinition;
        /**
         * The setup function is where you define the steps of your chain. It is
         * called with an object containing the params and a `step` function. You
         * call `step` to add a step to your chain.
         *
         * You can return an object from the setup function, which will be used as
         * the output of your chain. If you don't return anything, the output of
         * your chain will be the output of the last step.
         */
        setup(context: {
            /**
             * The inputs to the chain.
             */
            params: Variable<Prettify<ParamsToTypedObject<ChainParamsDefinition>>>;
            step: (typeof Chain)["prototype"]["step"];
            runIf: (typeof Chain)["prototype"]["runIf"];
            code: (typeof Chain)["prototype"]["code"];
            foreach: (typeof Chain)["prototype"]["foreach"];
        }): void | ChainOutputDefinition | null;
    }) => Chain<ChainParamsDefinition, ChainOutputDefinition>;
}
/**
 * Define an AI chain. This is the main entry point for creating chains.
 */
declare const defineChain: (typeof Chain)["define"];

export { Chain, defineChain, jsonSchemaParam, zodParam };
